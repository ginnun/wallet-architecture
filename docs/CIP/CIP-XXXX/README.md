---
CIP: 1
Title: Event-driven, wallet-opimised API
Status: Proposed
Category: Wallets
Authors:
  - William Wolff <william.wolff@iohk.io>
Implementors: N/A
Solution-To: CPS-????
Discussions:
Created: 2024-07-10
License: CC-BY-4.0
---

## Abstract

We propose an event-driven, push-based API optimized for wallet applications, leveraging the principle that a wallet's state should be a pure function of the blockchain state. This approach eliminates polling strategies and aggregating views, enabling real-time synchronization with the blockchain as new blocks are appended. Our solution addresses key challenges in current wallet implementations, including rollback handling, address discovery and multi-account support.

## Motivation: why is this CIP necessary?

The CIP provides a partial solution to the problems described in [CPS-????](../CPS/CPS-XXXX/README.md). In particular, we strive to define a standardized approach serving data to edge clients in an unopinionated, close to blockchain native format using a push-based protocol.

## Specification

### Table of Contents

[!TODO]

### Introduction

#### What does a wallet need to construct transactions?

- past transactions (receiving & spending) to derive balance and UTxO set
- rewards (staking, voting)
- network, era or epoch specific data, like:
  - protocol parameters (tx fees, plutus cost models, ...)
  - era summaries (slot length)
  - genesis (security param)
- the current tip/ block height for validity intervals of transactions as well as sync progress

#### How do we serve this data?

Through a push-based API, wallets are provided with a continuous stream of **relevant** on-chain events, enabling them to derive their current wallet state efficiently. This API supports various blockchain models, including UTXO-based chains and account-based chains. Additionally, clients receive secondary data relevant to the blockchain network they are subscribed to, ensuring comprehensive and up-to-date information.

#### Protocol

We use a bidirectional protocol (websockets) and encode all messages as JSON objects, while transactions contained in messages are preserved in the chain's native encoding standard (cbor). Messages adhere to a specific structure, ensuring consistency and facilitating efficient communication within our event-driven protocol. As we strive to support multiple blockchains, a server-sent message will always reference the originating chain it relates to.

### Message Types & Structure

We distinguish between client-sent and server-sent messages.

#### Client

Client-sent messages are **typed** messages, such as:

```json
{
  "type": "<unique message type>>"
  // ...
}
```

This allows the server to quickly identify the client's intent. More details on what typed messages exist will be covered in [Client Typed Messages](#client-typed-messages) section.

#### Server

Instead of typed messages, server-sent messages vary in structure depending on the underlying blockchain. Our design aims to be chain-agnostic and serve data from different blockchains in future. Therefore, we rely on **untyped** messages that are enriched and aggregated into compound messages. We call each top level key a server message partial.

This leads to a structure that has many top level keys of which, not every key may be present for every message, for example:

```json
{
  "transactions": [
    /* ... */
  ],
  "resolvedInputs": [
    /* ... */
  ],
  "rewards": {
    /* ... */
  },
  "tip": {
    /* ... */
  }
  // ...
}
```

> [!IMPORTANT]
>
> New message partials can be added at any time, which allows for flexible extension of the API.
> Clients are expected to iterate over message keys and skip those they do not support.

#### Errors

Any cases of server-side failure trigger an error message that is append as separate `error` message partial:

```json
{
  "error": {
    "type": "error type",
    "message": "error message"
  }
  /* ... */
}
```

### Authentication

A newly connected client authenicates as part of the [`subscribe`](#subscribe-message) message that is sent to the server to synchronize a specific wallet account up to the chain's current tip. This message must include a **signature** that verifies the ownership of provided extened public key (xpub).

The `signature` field is generated by signing a SHA256 HMAC hashed string. The prehash string is constructed by concatenating the subscribed blockchain(s) + timestamp.

The server verifies the signature and timestamp before serving any data to the client. If any part of the `subscribe` message is invalid, the server sends an error and closes the connection.

### Ordering of Events

Our API needs a reliable measurement of time to construct a stream of ordered, client-relevant, on-chain events that connected clients can easily consume. Time is crucial for clients for various reasons, including:

- monitoring the progress of synchronization up to the chain's tip
- defining transaction validity intervals

> [!NOTE]
> Transaction validity intervals allow clients to submit transactions with a specified lifetime, which serves several important purposes:
>
> - supports operations that need to occur within specific timeframes
> - helps manage network congestion by allowing expired transactions to be discarded
> - protects against replay attacks by ensuring transactions can't be resubmitted after expiration

We borrow the term `point` from the Cardano blockchain to introduce a sever-sent message partial. For instance, if a new transaction is deemed relevant for a connected client, the server enriches the message by adding the current "`point` in on-chain time" of the respective chain. For Cardano, this typically looks as follows:

#### Cardano Point

```json
{
  "point": {
    "slot": 127838345,
    "hash": "9f06ab6ecce25041b3a55db6c1abe225a65d46f7ff9237a8287a78925b86d10e"
  }
  /* ... */
}
```

> [!NOTE]
> Clients may safely assume that any serve-sent message, aside from error messages contain `point` partial.

### Synchronization

We refer to synchronization as the process that a wallet undertakes to catch up to the current chain's tip in order to derive its latest state and proceed to transact. The afore-described `point` represents the main anchor for wallets, to be able to:

- keep track of their current position in the blockchain
- resume the sync process since their last known point
- track and handle chain reorganizations (rollbacks)

The following sequence diagram shows, how a client connects providing an array of `point`s and extended public key. The client provides more than those two bits which is described in the [`subscribe`](#subscribe-message) message.
Subsequently, the server tries to find an intersection given the list of `point`s.

For an identified intersection, the server computes and publishes an ordered stream of events.
This event stream provides a chronological record of on-chain events and affectively state changes for the wallet to derive its latest state.

> [!NOTE]
> The server sources client-relevant data through credential-dependent, point-specific database queries, though the implementation details are beyond this CIP's scope.

![Sequence Diagram Synchronization](./images/02-Synchronization-Sequence.svg)

#### Resumability

Clients can resume synchronization from their last known `point`s after disconnecting. To minimize reconnection attempts, clients should provide a list of `point`s based on their most recent state, including some that may have been affected by rollbacks. This approach reduces the likelihood of the server failing to find a valid intersection, which would otherwise result in dropped connections and additional round trips.

> ![NOTE]
> More details are described in the [`subscribe`](#subscribe-message) message.

#### Rollback Handling

In a [CAP](https://en.wikipedia.org/wiki/CAP_theorem) system like Cardano, which balances global consistency with availability, there is a challenge in dealing with rollback events that impact transaction finality. Regardless of whether one uses their own full node or a server provider for transaction submission - if such events are not properly handled with the help of monitoring the rolling window of [k blocks](https://plutus-apps.readthedocs.io/en/latest/plutus/explanations/rollback.html) and respective resubmission, there is no guarantee that the transaction is finalized, eg. becomes part of the immutable pefix of the Cardano blockchain.

Since our wallet-optimized protocol defines that server-sent messages include the `point` message partial, the client can check if its last `point` is greater than any subsequent message `point` from the server, without the need to introduce a `rollback` specific message partial. This assumes that the client keeps a local copy of the mutuable suffix of the blockchain defined by the security parameter.

### Data Relevance for Clients

![TODO]

- server indexing data by credentials to optimize queries to retrieve client relevant data

## Rationale: how does this CIP achieve its goals?

### Authentication Optimization

- minimize initial exchange of messages + work on server side -> minimizes spam attach vectors

### Client Typed Messages

#### Heartbeat

The client sends this message periodically to the server after establishing a connection. Its purpose is to:

1. Inform the server that the client is still active and connected
2. Prevent the server from terminating the connection due to inactivity

##### Heartbeat Schema

```json
{
  "type": "heartbeat"
}
```

##### Frequency

Clients should send heartbeat messages every 30 seconds to maintain the connection.

#### Subscribe Message

Sent by client to server right after establishing a connection. New clients must authenticate themselves when subscribing to any blockchain events via a signature.

##### Subscribe Schema

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "type": {
      "type": "string",
      "enum": ["subscribe"]
    },
    "topics": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "blockchain": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string"
              },
              "network": {
                "type": "string"
              }
            },
            "required": ["name", "network"]
          },
          "publicKey": {
            "type": "string",
            "pattern": "^[A-Za-z0-9+/=]*$"
          },
          "signature": {
            "type": "string",
            "pattern": "^[A-Za-z0-9+/=]*$"
          },
          /* <blockchain specific grouped fields> */
          "cardano": {
            "type": "object",
            "properties": {
              "credentials": {
                "type": "object",
                "properties": {
                  "payment": {
                    "type": "array",
                    "items": {
                      "type": "string",
                      "pattern": "^[A-Za-z0-9+/=]*$"
                    }
                  },
                  "stake": {
                    "type": "array",
                    "items": {
                      "type": "string",
                      "pattern": "^[A-Za-z0-9+/=]*$"
                    }
                  }
                },
                "required": ["payment", "stake"]
              },
              "config": {
                "type": "object",
                "properties": {
                  "resolveTxInput": {
                    "type": "boolean",
                    "default": false
                  },
                  "assetMetadata": {
                    "type": "boolean",
                    "default": false
                  }
                }
              }
            },
            "required": ["credentials", "config"]
          }
        },
        "required": ["blockchain", "publicKey", "signature"]
      }
    },
    "timestamp": {
      "type": "string",
      "format": "date-time"
    }
  },
  "required": ["type", "topics", "timestamp"],
  "additionalProperties": false
}
```

The `signature` field is generated by signing a SHA256 HMAC hashed string. The prehash string is constructed by concatenating the subscribed `blockchains` + `timestamp`.

> [!NOTE]
> For subscribing to multiple blockchains, the prehash string must be generated for each as `<blockchain.name>.<blockchain.network>`, for example:
> `cardano.mainnet+2024-06-27T12:34:56Z`.

Apply a SHA256 HMAC using either the payment signing key or staking signing key, and then base64-encode it as final payload within the initial message. Pass the output of this SHA256 HMAC to the signature field.

The signature verifies ownership of the private key, whose corresponding public key is used to filter relevant block transactions.

##### Subscribe Example

```json
{
  "type": "subscribe",
  "topics": [
    {
      "blockchain": { "name": "cardano", "network": "mainnet" },
      "publicKey": "publicKey_example",
      "signature": "OGNiOWIyNGVjOTMxZmY3N2MzYjQxOTY3OWE0YTcwMzczZmVkZmIxNDZmMDE0ODk0Nzg4YjUxMmIzMjE4MDdiYw==", // base64, SHA256 HMAC with your signing key
      "cardano": {
        "credentials": {
          "payment": ["script...", "addr_vkh..."], // this field follows  CIP-0005
          "stake": ["script...", "addr_vkh..."] // this field follows  CIP-0005
        },
        "config": {
          "resolveTxInput": true,
          "assetMetadata": true
        }
      }
    }
  ],
  "timestamp": "2024-06-27T12:34:56Z"
}
```

##### Subscription Object

The subscription object is blockchain specific, because there are different networks, credentials or other fields required.
Chain specific fields are grouped under a specific field named after the given chain.
In the case of Cardano blockchain, all the relevant fields are placed under a field named `cardano`.
Below we list the currently supported subscriptions:

##### Cardano

This is the format for a Cardano specific object in the `topics` array. A client can subscribe to multiple accounts at once by providing multiple objects or one by one at any given time.

```json
{
  "blockchain": {
    "name": "cardano",
    "network": {
      "type": "string",
      "enum": ["mainnet", "preprod", "preview"]
    }
  },
  "publicKey": {
    "type": "string"
  },
  "signature": {
    "type": "string",
    "pattern": "^[A-Za-z0-9+/=]*$"
  },
  "cardano": {
    "type": "object",
    "properties": {
      "credentials": {
        "type": "object",
        "properties": {
          "payment": {
            "type": "array",
            "items": {
              "type": "string",
              "pattern": "^[A-Za-z0-9+/=]*$"
            }
          },
          "stake": {
            "type": "array",
            "items": {
              "type": "string",
              "pattern": "^[A-Za-z0-9+/=]*$"
            }
          }
        },
        "required": ["payment", "stake"]
      },
      "config": {
        "type": "object",
        "properties": {
          "resolveTxInput": {
            "type": "boolean",
            "default": false
          },
          "assetMetadata": {
            "type": "boolean",
            "default": false
          }
        }
      }
    },
    "required": ["credentials", "config"]
  },
  "required": ["blockchain", "publicKey", "signature", "cardano"]
}
```

##### Other blockchains

Any other blockchain schema should follow the same structure as the above Cardano example by applying these:

- Group blockchain specific properties under one property named after the blockchain (see `cardano` field)
- Keep chain specific authentication fields under `credentials` property
- Keep chain specific configuration fields under `config` property
- Define a JSON Schema in the documentation

#### Unsubscribe Message

The client sends this message to the server to gracefully terminate a connection. It allows for proper cleanup and resource management on the server side.

The client should send this message in two scenarios:

1. Before intentionally closing a connection
2. When the client application is shutting down

```json
{
  "type": "unsubscribe"
}
```

##### Server Behavior

Upon receiving an unsubscribe message, the server will:

1. Acknowledge the message
2. Close the connection
3. Release any resources associated with the client's session

##### Server Acknowledge Message

```json
{
  "type": "acknowledge",
  "status": "success",
  "timestamp": "2024-06-27T14:30:00Z"
}
```

##### Server Response

The server does not send a response to heartbeat messages. It simply resets the connection's inactivity timer upon receipt.

> [!NOTE]
> If the server doesn't receive a heartbeat message within 90 seconds of the last received message (of any type), it may terminate the connection.

Clients should implement error handling to re-establish the connection if it's terminated.

### Server Message Partials

Different blockchains have different **periodic** events that are not related to specific transactions, but are required for either transaction construction or necessary to derive the correct wallet state. These events get represented by additional top level message keys (message partial) correlated to a chain [`point`](#ordering-of-events).

We differentiate between [Ledger](#ledger-events) and [Network](#network-events) events.

#### Ledger Events

Ledger events are specific occurrences that directly affect the state of a blockchain's ledger. These events typically involve changes to account balances, transaction histories, and other financial records.

##### Ledger Event Examples

- new transactions
- smart contract interactions
- token transfers
- stake delegation changes

#### Network Events

Network events are occurrences that impact the overall operation and configuration of the blockchain network but do not directly alter the ledger's state. These events often involve changes to the network's consensus mechanism, protocol parameters, or infrastructure.

##### Network Event Examples

- Epoch Transitions: Periodic changes in the network's epoch, which can involve updates to [protocol parameters](#protocol-parameter-server-message-partial) and rewards from staking or voting.
- Era/ Network Transitions: Cardano has transitioned through different [eras](https://roadmap.cardano.org/en/) which add/ remove or change certain network properties

#### Protocol Parameter Server Message Partial

This top level message key is added by the server as part of any synchronization process for every epoch boundary transition.

> [!NOTE]
> It is specific to the Cardano blockchain.

##### Protocol Paramter Schema

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "epoch": {
      "type": "integer"
    },
    "minFeeA": {
      "type": "integer"
    },
    "minFeeB": {
      "type": "integer"
    },
    "maxBlockSize": {
      "type": "integer"
    },
    "maxTxSize": {
      "type": "integer"
    },
    "maxBlockHeaderSize": {
      "type": "integer"
    },
    "keyDeposit": {
      "type": "string"
    },
    "poolDeposit": {
      "type": "string"
    },
    "eMax": {
      "type": "integer"
    },
    "nOpt": {
      "type": "integer"
    },
    "a0": {
      "type": "number"
    },
    "rho": {
      "type": "number"
    },
    "tau": {
      "type": "number"
    },
    "decentralisationParam": {
      "type": "number"
    },
    "extraEntropy": {
      "type": ["null", "string"]
    },
    "protocolMajorVer": {
      "type": "integer"
    },
    "protocolMinorVer": {
      "type": "integer"
    },
    "minUtxo": {
      "type": "string"
    },
    "minPoolCost": {
      "type": "string"
    },
    "nonce": {
      "type": "string"
    },
    "costModels": {
      "type": "object",
      "properties": {
        "plutusV1": {
          "type": "object",
          "additionalProperties": {
            "type": "integer"
          }
        },
        "plutusV2": {
          "type": "object",
          "additionalProperties": {
            "type": "integer"
          }
        }
      }
    },
    "priceMem": {
      "type": "number"
    },
    "priceStep": {
      "type": "number"
    },
    "maxTxExMem": {
      "type": "string"
    },
    "maxTxExSteps": {
      "type": "string"
    },
    "maxBlockExMem": {
      "type": "string"
    },
    "maxBlockExSteps": {
      "type": "string"
    },
    "maxValSize": {
      "type": "string"
    },
    "collateralPercent": {
      "type": "integer"
    },
    "maxCollateralInputs": {
      "type": "integer"
    },
    "coinsPerUtxoSize": {
      "type": "string"
    }
  },
  "required": [
    "epoch",
    "minFeeA",
    "minFeeB",
    "maxBlockSize",
    "maxTxSize",
    "maxBlockHeaderSize",
    "keyDeposit",
    "poolDeposit",
    "eMax",
    "nOpt",
    "a0",
    "rho",
    "tau",
    "decentralisationParam",
    "extraEntropy",
    "protocolMajorVer",
    "protocolMinorVer",
    "minUtxo",
    "minPoolCost",
    "nonce",
    "costModels",
    "priceMem",
    "priceStep",
    "maxTxExMem",
    "maxTxExSteps",
    "maxBlockExMem",
    "maxBlockExSteps",
    "maxValSize",
    "collateralPercent",
    "maxCollateralInputs",
    "coinsPerUtxoSize"
  ]
}
```

##### Protocol Parameters Example

```json
{
  "protocolParameters": {
    "epoch": 225,
    "minFeeA": 44,
    "minFeeB": 155381,
    "maxBlockSize": 65536,
    "maxTxSize": 16384,
    "maxBlockHeaderSize": 1100,
    "keyDeposit": "2000000",
    "poolDeposit": "500000000",
    "eMax": 18,
    "nOpt": 150,
    "a0": 0.3,
    "rho": 0.003,
    "tau": 0.2,
    "decentralisationParam": 0.5,
    "extraEntropy": null,
    "protocolMajorVer": 2,
    "protocolMinorVer": 0,
    "minUtxo": "1000000",
    "minPoolCost": "340000000",
    "nonce": "1a3be38bcbb7911969283716ad7aa550250226b76a61fc51cc9a9a35d9276d81",
    "costModels": {
      "plutusV1": {
        "addIntegerCpuArgumentsIntercept": 197209,
        "addIntegerCpuArgumentsSlope": 0
      },
      "plutusV2": {
        "addIntegerCpuArgumentsIntercept": 197209,
        "addIntegerCpuArgumentsSlope": 0
      }
    },
    "priceMem": 0.0577,
    "priceStep": 0.0000721,
    "maxTxExMem": "10000000",
    "maxTxExSteps": "10000000000",
    "maxBlockExMem": "50000000",
    "maxBlockExSteps": "40000000000",
    "maxValSize": "5000",
    "collateralPercent": 150,
    "maxCollateralInputs": 3,
    "coinsPerUtxoSize": "34482"
  }
}
```

## Path to Active

## Copyright

This CIP is licensed under [CC-BY-4.0](https://creativecommons.org/licenses/by/4.0/legalcode).
