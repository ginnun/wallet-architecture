---
CIP: 1
Title: Event-driven, wallet-opimised API
Status: Proposed
Category: Wallets
Authors:
    - William Wolff <william.wolff@iohk.io>
Implementors: N/A
Solution-To: [CPS-????](../CPS/CPS-XXXX/README.md)
Discussions:
Created: 2024-07-10
License: CC-BY-4.0
---

## Abstract

We propose an event-driven, push-based API optimized for wallet applications, leveraging the principle that a wallet's state should be a pure function of the blockchain state. This approach eliminates polling strategies and aggregating views, enabling real-time synchronization with the blockchain as new blocks are appended. Our solution addresses key challenges in current wallet implementations, including rollback handling, address discovery and multi-account support.

## Motivation: why is this CIP necessary?

The CIP provides a partial solution to the problems described in [CPS-????](../CPS/CPS-XXXX/README.md). In particular, the need for a standardized approach serving data in an unopinionated, close to blockchain native format.

## Specification

### Table of Contents

[!TODO]

### Introduction

#### What does a wallet need to construct transactions?

Generally, a wallet requires the following data:

- past transactions (receiving & spending)
- rewards (staking, voting)
- network, era or epoch specific data, like:
  - protocol parameters (tx fees, plutus cost models, ...)
  - era summaries (slot length)
  - genesis (security param)
- the current tip/ block height for validity intervals of transactions

#### How do we serve this data?

Through a push-based API, wallets are provided with a continuous stream of **relevant** on-chain events, enabling them to derive their current wallet state efficiently. This API supports various blockchain models, including UTXO-based chains and account-based chains. Additionally, clients receive secondary data relevant to the blockchain network they are subscribed to, ensuring comprehensive and up-to-date information.

#### Protocol

We use a bidirectional protocol (websockets) and encode all messages as JSON objects, while transactions contained in messages are preserved in the chain's native encoding standard (cbor). Messages adhere to a specific structure, ensuring consistency and facilitating efficient communication within our event-driven protocol. As we strive to support multiple blockchains, a server-sent message will always reference the originating chain it relates to.

### Message Types & Structure

We distinguish between client-sent and server-sent messages.

#### Client

Client-sent messages are **typed** messages, such as:

```json
{
  "type": "<unique message type>>",
  // ...
}
```

This allows the server to quickly identify the client's intent. More details on what typed messages exist will be covered further below.

#### Server

Instead of typed messages, server-sent messages vary in structure depending on the underlying blockchain. Our design aims to be chain-agnostic and serve data from different blockchains in future. Therefore, we rely on **untyped** messages that are enriched and aggregated into compound messages. We call each top level key a server message partial.

This leads to a structure that has many top level keys of which not every one key needs to present for every message, for example:

```json
{
  "transactions": [ /* ... */ ],
  "resolvedInputs": [ /* ... */ ],
  "rewards": { /* ... */ },
  "tip": { /* ... */ },
  // ...
}
```

> [!NOTE]
>
> New message partials can be added at any time, which allows for flexible extension of the API.
> Clients are expected to iterate over message keys and skip those they do not support.

### Authentication

A newly connected client authenicates as part of the [`subscribe`](./#subscribe) message that is sent to the server to synchronize a specific wallet account up to the chain's current tip. This message must include a **signature** that verifies the ownership of provided credentials (payment/ stake) at around time of connecting.

The `signature` field is generated by signing a SHA256 HMAC hashed string. The prehash string is constructed by concatenating the subscribed blockchains + timestamp.

### Ordering of Events

Our API needs a reliable measurement of time to construct a stream of ordered, client-relevant, on-chain events that connected clients can easily consume. Time is crucial for clients for various reasons, including:

- monitoring the progress of synchronization up to the chain's tip
- defining transaction validity intervals

> [!NOTE]
> Transaction validity intervals allow clients to submit transactions with a specified lifetime, which serves several important purposes:
>
> - protects against replay attacks by ensuring transactions can't be resubmitted after expiration
> - helps manage network congestion by allowing expired transactions to be discarded
> - supports operations that need to occur within specific timeframes

We borrow the term `point` from the Cardano blockchain to introduce an **always present** sever-sent message partial. For instance, if a new transaction is deemed relevant for a connected client, the server enriches the message by adding the current "`point` in on-chain time" of the respective chain. For Cardano, this typically looks as follows:

#### Cardano Point

```json
{
  "point": {
    "slot": 127838345,
    "hash": "9f06ab6ecce25041b3a55db6c1abe225a65d46f7ff9237a8287a78925b86d10e"
  }
  /* ... */
}
```

### Data Relevance for Clients

## Rationale: how does this CIP achieve its goals?

## Path to Active

## Copyright

This CIP is licensed under [CC-BY-4.0](https://creativecommons.org/licenses/by/4.0/legalcode).